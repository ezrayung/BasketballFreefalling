<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HKDSE Physics: Height & Velocity (TSKSS Edition)</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --accent-color: #e67e22;
            --bg-color: #ecf0f1;
            --panel-bg: #ffffff;
            --text-color: #333;
        }

        * { box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        header {
            background-color: var(--primary-color);
            color: white;
            padding: 8px 15px;
            flex: 0 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            z-index: 10;
        }

        h1 { margin: 0; font-size: 1.1rem; letter-spacing: 0.5px; }
        .subtitle { font-size: 0.85rem; opacity: 0.9; }
        .badge { background: #34495e; padding: 2px 6px; border-radius: 4px; font-size: 0.7rem; margin-left: 5px; border: 1px solid #7f8c8d; }

        #main-container {
            flex: 1 1 auto;
            display: flex;
            gap: 10px;
            padding: 10px;
            min-height: 0;
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
        }

        #sim-panel {
            flex: 3;
            background: var(--panel-bg);
            border-radius: 6px;
            border: 1px solid #ddd;
            position: relative;
            display: flex;
            min-height: 0;
            overflow: hidden;
        }

        canvas#simCanvas { width: 100%; height: 100%; display: block; }

        #graph-panel {
            flex: 2;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-height: 0;
        }

        .graph-container {
            flex: 1;
            background: var(--panel-bg);
            border-radius: 6px;
            border: 1px solid #ddd;
            position: relative;
            min-height: 0;
            display: flex;
        }

        canvas.graphCanvas { width: 100%; height: 100%; display: block; }

        #controls {
            background: var(--panel-bg);
            padding: 10px 15px;
            border-top: 1px solid #ccc;
            flex: 0 0 auto;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            font-size: 0.9rem;
        }

        .control-group { display: flex; align-items: center; gap: 8px; }

        button {
            padding: 6px 16px;
            font-size: 0.9rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
        }

        #btn-start { background-color: #27ae60; color: white; }
        #btn-start:hover { background-color: #219150; }
        #btn-reset { background-color: #7f8c8d; color: white; }
        #btn-reset:hover { background-color: #626e6f; }

        input[type=range] { cursor: pointer; height: 5px; }
        
        .graph-label {
            position: absolute;
            top: 4px;
            left: 8px;
            font-weight: bold;
            font-size: 0.75rem;
            background: rgba(255,255,255,0.9);
            padding: 1px 4px;
            border-radius: 3px;
            border: 1px solid #eee;
            pointer-events: none;
        }
        
        .s-color { color: #2980b9; border-left: 3px solid #2980b9; } 
        .v-color { color: #d35400; border-left: 3px solid #d35400; } 
        .a-color { color: #8e44ad; border-left: 3px solid #8e44ad; } 

    </style>
</head>
<body>

<header>
    <h1>HKDSE Physics Studio</h1>
    <span class="subtitle">
        <span class="badge">s = Height</span>
        <span class="badge">v = Down (+)</span>
    </span>
</header>

<div id="main-container">
    <div id="sim-panel">
        <canvas id="simCanvas"></canvas>
        <div style="position: absolute; bottom: 10px; left: 10px; font-size: 0.75rem; color: #7f8c8d; font-weight: bold;">
            Ground (s = 0)
        </div>
    </div>

    <div id="graph-panel">
        <div class="graph-container">
            <span class="graph-label s-color">s-t (Height)</span>
            <canvas id="canvasS" class="graphCanvas"></canvas>
        </div>
        <div class="graph-container">
            <span class="graph-label v-color">v-t (Velocity, Down+)</span>
            <canvas id="canvasV" class="graphCanvas"></canvas>
        </div>
        <div class="graph-container">
            <span class="graph-label a-color">a-t (Acceleration)</span>
            <canvas id="canvasA" class="graphCanvas"></canvas>
        </div>
    </div>
</div>

<div id="controls">
    <div class="control-group">
        <button id="btn-start">Start</button>
        <button id="btn-reset">Reset</button>
    </div>
    
    <div class="control-group">
        <label for="heightRange">Initial Height:</label>
        <input type="range" id="heightRange" min="2" max="10" value="8" step="1">
        <span id="heightVal" style="width: 30px">8m</span>
    </div>

    <div class="control-group">
        <label for="bounceRange">Bounciness:</label>
        <input type="range" id="bounceRange" min="0.3" max="0.9" value="0.75" step="0.05">
        <span id="bounceVal" style="width: 30px">0.75</span>
    </div>
</div>

<script>
    // --- Configuration ---
    const CONFIG = {
        g: 9.81,            // Positive because Down is + in v-t graph
        pixelsPerMeter: 30, 
        ballRadiusM: 0.3,
        fps: 60
    };

    // --- State ---
    let state = {
        running: false,
        time: 0,
        height: 0,     // s (Height above ground)
        velocity: 0,   // v (Down is positive)
        accel: CONFIG.g,
        history: [],   
        isResting: false
    };

    // --- Elements ---
    const simCanvas = document.getElementById('simCanvas');
    const ctxSim = simCanvas.getContext('2d');
    const canvasS = document.getElementById('canvasS');
    const ctxS = canvasS.getContext('2d');
    const canvasV = document.getElementById('canvasV');
    const ctxV = canvasV.getContext('2d');
    const canvasA = document.getElementById('canvasA');
    const ctxA = canvasA.getContext('2d');

    const btnStart = document.getElementById('btn-start');
    const btnReset = document.getElementById('btn-reset');
    const sliderHeight = document.getElementById('heightRange');
    const displayHeight = document.getElementById('heightVal');
    const sliderBounce = document.getElementById('bounceRange');
    const displayBounce = document.getElementById('bounceVal');

    let animationFrameId;
    let initialHeight = 8;
    let restitution = 0.75;

    // --- Resizing ---
    const resizeObserver = new ResizeObserver(() => {
        resizeCanvases();
        drawAll(); 
    });
    resizeObserver.observe(document.getElementById('sim-panel'));
    resizeObserver.observe(document.getElementById('graph-panel'));

    function resizeCanvases() {
        [simCanvas, canvasS, canvasV, canvasA].forEach(canv => {
            const rect = canv.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canv.width = rect.width * dpr;
            canv.height = rect.height * dpr;
            const ctx = canv.getContext('2d');
            ctx.scale(dpr, dpr);
            canv.logicalWidth = rect.width;
            canv.logicalHeight = rect.height;
        });
    }

    // --- Physics Engine ---
    function updatePhysics(dt) {
        if (state.isResting) return;

        let prevV = state.velocity;
        
        // 1. Acceleration is constant +9.8 (Down)
        state.velocity += state.accel * dt;
        
        // 2. Height decreases when velocity is positive (Falling)
        state.height -= state.velocity * dt;

        // 3. Ground Collision
        if (state.height <= 0) {
            state.height = 0; 
            if (Math.abs(prevV) < 1.5) { 
                state.velocity = 0;
                state.accel = 0;
                state.isResting = true;
                state.history.push({ t: state.time, s: 0, v: 0, a: 0 });
            } else {
                // Rebound: Velocity becomes Negative (Upwards)
                state.velocity = -Math.abs(prevV) * restitution;
            }
        }
        
        state.time += dt;

        state.history.push({
            t: state.time,
            s: state.height,
            v: state.velocity,
            a: state.accel
        });

        if (state.time > 20 && state.history.length > 2000) state.history.shift();
    }

    // --- Drawing Simulation ---
    function drawSimulation() {
        const width = simCanvas.logicalWidth;
        const height = simCanvas.logicalHeight;
        const centerX = width / 2;
        
        ctxSim.clearRect(0, 0, width, height);

        // 1. Draw Background Text (Tang Shiu Kin Secondary School)
        ctxSim.save();
        ctxSim.fillStyle = 'rgba(0,0,0,0.06)'; // Very subtle grey watermark
        const fontSize = Math.max(24, width / 20);
        ctxSim.font = "bold " + fontSize + "px Arial, sans-serif";
        ctxSim.textAlign = "center";
        ctxSim.textBaseline = "middle";
        ctxSim.fillText("Tang Shiu Kin Secondary School", centerX, height / 2);
        ctxSim.restore();


        // Dynamic Scaling
        const margin = 30;
        const maxSimH = 12; 
        const scale = (height - margin) / maxSimH; 
        const groundY = height - 20; 

        // Ground
        ctxSim.fillStyle = '#bdc3c7';
        ctxSim.fillRect(0, groundY, width, 20);

        // Ruler
        ctxSim.fillStyle = '#95a5a6';
        ctxSim.font = "10px Arial";
        for(let m = 0; m <= 12; m+=1) {
            let yPos = groundY - (m * scale);
            if(yPos > 10) {
                ctxSim.fillRect(centerX - 80, yPos, 10, 1);
                if(m % 2 === 0) ctxSim.fillText(m + 'm', centerX - 105, yPos + 3);
            }
        }

        // Ball
        let ballPixelY = groundY - (state.height * scale) - (CONFIG.ballRadiusM * scale);
        let ballRadius = CONFIG.ballRadiusM * scale;

        // Shadow
        ctxSim.beginPath();
        let shadowScale = Math.max(0, 1 - (state.height / 5));
        ctxSim.ellipse(centerX, groundY + 5, ballRadius * shadowScale, ballRadius * 0.3 * shadowScale, 0, 0, Math.PI * 2);
        ctxSim.fillStyle = 'rgba(0,0,0,0.1)';
        ctxSim.fill();

        // Ball Body
        ctxSim.beginPath();
        ctxSim.arc(centerX, ballPixelY, ballRadius, 0, Math.PI * 2);
        ctxSim.fillStyle = '#d35400'; 
        ctxSim.fill();
        ctxSim.strokeStyle = '#333';
        ctxSim.stroke();

        // Vectors (Thick but shorter)
        if (!state.isResting) {
            // Set thick lines for vectors
            ctxSim.lineWidth = 4;

            // Velocity Arrow
            if (Math.abs(state.velocity) > 0.1) {
                // Reduced scale factor: Divided by 3.0 instead of 1.5 (Halved the length)
                let vLen = state.velocity * (scale / 3.0);
                drawArrow(ctxSim, centerX + ballRadius + 25, ballPixelY, 0, vLen, '#d35400', 'v');
            }
            
            // Acceleration Arrow
            if (state.height > 0) {
                 // Reduced scale factor: Divided by 3.0 instead of 1.5
                drawArrow(ctxSim, centerX - ballRadius - 25, ballPixelY, 0, state.accel * (scale / 3.0), '#8e44ad', 'a');
            }
            // Reset line width just in case
            ctxSim.lineWidth = 1;
        }
    }

    function drawArrow(ctx, x, y, dx, dy, color, label) {
        const headlen = 15; // Larger arrowhead
        const angle = Math.atan2(dy, dx);
        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        // lineWidth is set by caller

        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + dx, y + dy);
        ctx.stroke();
        
        // Draw arrowhead
        ctx.beginPath();
        ctx.moveTo(x + dx, y + dy);
        ctx.lineTo(x + dx - headlen * Math.cos(angle - Math.PI / 6), y + dy - headlen * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(x + dx - headlen * Math.cos(angle + Math.PI / 6), y + dy - headlen * Math.sin(angle + Math.PI / 6));
        ctx.closePath();
        ctx.fill();

        // Larger label font
        ctx.save();
        ctx.font = "bold 16px Arial"; 
        ctx.fillText(label, x + dx + 15, y + dy + 5);
        ctx.restore();
    }

    // --- Drawing Graphs ---
    function drawGraphs() {
        const maxTime = Math.max(5, state.time * 1.05);
        drawGraph(ctxS, canvasS, state.history, 's', maxTime, 12, 0, '#2980b9'); 
        drawGraph(ctxV, canvasV, state.history, 'v', maxTime, 15, -15, '#d35400');
        drawGraph(ctxA, canvasA, state.history, 'a', maxTime, 15, -5, '#8e44ad');
    }

    function drawGraph(ctx, canvas, data, key, maxT, maxVal, minVal, color) {
        const w = canvas.logicalWidth;
        const h = canvas.logicalHeight;
        const p = {top: 10, bottom: 20, left: 35, right: 10};

        ctx.clearRect(0, 0, w, h);
        
        const mapX = (t) => p.left + (t / maxT) * (w - p.left - p.right);
        const mapY = (val) => (h - p.bottom) - ((val - minVal) / (maxVal - minVal)) * (h - p.bottom - p.top);

        const yZero = mapY(0);
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#ddd';
        ctx.beginPath();
        if(yZero > p.top && yZero < h - p.bottom) {
            ctx.moveTo(p.left, yZero);
            ctx.lineTo(w - p.right, yZero);
            ctx.stroke();
        }

        ctx.strokeStyle = '#999';
        ctx.beginPath();
        ctx.moveTo(p.left, p.top);
        ctx.lineTo(p.left, h - p.bottom);
        ctx.lineTo(w - p.right, h - p.bottom);
        ctx.stroke();

        ctx.fillStyle = '#666';
        ctx.font = "9px Arial";
        ctx.textAlign = "right";
        ctx.fillText(maxVal, p.left - 4, mapY(maxVal) + 3);
        ctx.fillText(minVal, p.left - 4, mapY(minVal) + 3);
        if(minVal < 0 && maxVal > 0) ctx.fillText("0", p.left - 4, yZero + 3);

        if (data.length === 0) return;
        ctx.beginPath();
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.moveTo(mapX(data[0].t), mapY(data[0][key]));
        
        let step = Math.ceil(data.length / w) || 1; 
        for (let i = 1; i < data.length; i+=step) {
            ctx.lineTo(mapX(data[i].t), mapY(data[i][key]));
        }
        ctx.lineTo(mapX(data[data.length-1].t), mapY(data[data.length-1][key]));
        ctx.stroke();
        
        const last = data[data.length-1];
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(mapX(last.t), mapY(last[key]), 3, 0, Math.PI*2);
        ctx.fill();
    }

    function drawAll() {
        drawSimulation();
        drawGraphs();
    }

    function loop() {
        if (!state.running) return;
        updatePhysics(1/CONFIG.fps);
        drawAll();
        if (state.running) animationFrameId = requestAnimationFrame(loop);
    }

    function resetSim() {
        state.running = false;
        cancelAnimationFrame(animationFrameId);
        btnStart.textContent = "Start";
        
        initialHeight = parseInt(sliderHeight.value);
        state.time = 0;
        state.height = initialHeight;
        state.velocity = 0;
        state.accel = CONFIG.g;
        state.history = [];
        state.isResting = false;
        
        state.history.push({ t:0, s: initialHeight, v:0, a:CONFIG.g });
        drawAll();
    }

    btnStart.addEventListener('click', () => {
        state.running = !state.running;
        btnStart.textContent = state.running ? "Pause" : "Resume";
        if (state.running) loop();
    });

    btnReset.addEventListener('click', resetSim);

    sliderHeight.addEventListener('input', (e) => {
        displayHeight.textContent = e.target.value + "m";
        if (!state.running) resetSim();
    });

    sliderBounce.addEventListener('input', (e) => {
        restitution = parseFloat(e.target.value);
        displayBounce.textContent = restitution;
    });

    resizeCanvases();
    resetSim();

</script>
</body>
</html>